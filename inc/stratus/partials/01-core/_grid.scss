$min-column-width: 200px;

.grid {
  --grid-gap: s(1);
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(#{$min-column-width}, 1fr));
  grid-gap: var(--grid-gap);
}

// To limit the maximum number of columns, it would be great to be able to declaire that in the property
// like grid-template-columns: repeat(minmax(auto-fill, 3), minmax(#{$min-column-width}, 1fr));
// Sadly, this notation is invalid and a native solution may not be added

// Next, we can look at media queries
// The problem with this approach is that it is that its pretty clunky and must be configured per project.
// This also would best work as a container query if those every get added, as we really want to know
// the width of the grid container, not the screen. Something like .grid:media(min-width: #{$min-column-width * 2.5})

// If the container is wide enough to accomidate X columns, lock it at X
@media (min-width: #{$min-column-width * 2.5}) {
  .column-2-max { grid-template-columns: repeat(2, 1fr); }
  .span-2 { grid-column: span 2; }
}
@media (min-width: #{$min-column-width * 3.5}) {
  .column-3-max { grid-template-columns: repeat(3, 1fr); }
  .span-3 { grid-column: span 3; }
}
@media (min-width: #{$min-column-width * 4.5}) {
  .column-4-max { grid-template-columns: repeat(4, 1fr); }
  .span-4 { grid-column: span 4; }
}
@media (min-width: #{$min-column-width * 5.5}) {
  .column-5-max { grid-template-columns: repeat(5, 1fr); }
  .span-5 { grid-column: span 5; }
}
@media (min-width: #{$min-column-width * 6.5}) {
  .column-6-max { grid-template-columns: repeat(6, 1fr); }
  .span-6 { grid-column: span 6; }
}

// To get around container queries, we could use Javascript to assign a class to the
// grid container when it is wide enough for each column to be added,
// but again, this is quite clunky and brings in additional reliance on JavaScript that should be unnecessary.
// <div class="grid" data-columns="2 3">
// .grid-2-max[data-columns*="2"] { grid-template-columns: repeat(2, 1fr); }
// This type of JavaScript would likely have to be triggered on page resize which could be expensive?

// For more control, we can use a possibly better practice of using portrait / landscape queries
// Min width would still have to be used however to see when 2 columns can fit
@media (orientation: landscape) and (min-width: #{$min-column-width * 2.5}) {
  .span-2-landscape { grid-column: span 2 };
}

// On a global note, the media calculations are also a little loose because it doesn't account for the grid gap.
// You could get around this by making sure the grid gap and minimum column width are in the same measurement.
// Even so, it would force you to make the grid gap a fixed value since CSS custom properties can not
// be used in media queries. The correct formula to see if X columns can fit in the grid is
// $grid-width - ($grid-gap * ( $X - 1 )) >= ($min-column-width * $X) where $X is the number of columns to check.

// As for browser compatibility, its worth noting that no solution that relies on CSS grid will work on IE
// Even though IE supports a version of the CSS Grid spec, auto positioning does not work.

// We can also look at flexbox
// Allowing the flex container to wrap will give us a responsive effect, and flex-grow will ensure every item
// takes up the available space. The grid gap becomes extremely hacky and messy because of the margin offsets
// and the layout overall feels fragile and subject to odd browser bugs. Spanning a specific number of columns
// also becomes a little more vague because it must rely on a universal background grid, likely based on 12 columns.
.flex {
  --grid-gap: s(1);
  display: flex;
  flex-wrap: wrap;
  margin-left: calc(var(--grid-gap) * -1);
}
.flex > * {
  min-width: $min-column-width;
  max-width: 100%;
  flex-grow: 1;
  margin-left: var(--grid-gap);
}
.flex.column-2-max > * {
  flex-basis: calc(50% - var(--grid-gap));
}
.flex > *.span-all {
  flex-basis: 100%;
}